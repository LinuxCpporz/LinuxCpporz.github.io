<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>云渺阿姨的学习笔记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <meta name="renderer" content="webkit">
    <meta http-equiv="Cache-Control" content="no-siteapp"/>
    <link rel="stylesheet" href="/styles/main.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@1.0.1/dist/css/mdui.min.css">
    <link rel="stylesheet" href="/media/css/post.css">
    <link rel="stylesheet" href="/media/live2d/css/live2d.css" />
    
</head>
<body class=" mdui-appbar-with-toolbar  mdui-theme-primary-pink mdui-theme-accent-pink">
<header class="mdui-toolbar mdui-color-pink mdui-appbar-fixed mdui-appbar-scroll-toolbar-hide" style="z-index: 1000">
    <a href="javascript:;" mdui-drawer="{target: '#left-drawer',overlay:true}" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">menu</i></a>
    <span class="mdui-typo-title">云渺阿姨的学习笔记</span>
    <div class="mdui-toolbar-spacer"></div>
<!--    <a href="javascript:history.go(0);" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
    <a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">more_vert</i></a>
</header>

<div class="mdui-drawer mdui-color-white mdui-drawer-full-height mdui-drawer-close" id="left-drawer">
    <ul class="mdui-list">
        <li class="mdui-subheader">菜单</li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="https://linuxcpporz.github.io" class="mdui-list-item-content">首页</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="https://linuxcpporz.github.io/archives" class="mdui-list-item-content">归档</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="https://linuxcpporz.github.io/tags" class="mdui-list-item-content">标签</a>
        </li>
        
        <li class="mdui-list-item mdui-ripple">
            <a href="https://linuxcpporz.github.io/post/about" class="mdui-list-item-content">关于</a>
        </li>
        
    </ul>
</div>

<div id="content" class="site-content">
    <div id="primary" class="content-area">
        <main id="main" class="site-main" role="main">
            <article id="post-1270" class="post-1270 post type-post status-publish format-standard hentry category-90 category-129 tag-149">
                <header class="entry-header">
                    <h1 class="entry-title">C++实现十大排序算法</h1>
                    <p class="entry-census">发布于 2021-10-19</p>
                    <hr>
                </header>
                <div class="neko">
                    <figure data-type="image" tabindex="1"><img src="https://linuxcpporz.github.io/post-images/1634574732046.png" alt="" loading="lazy"></figure>
<h1 id="1-冒泡排序">1 冒泡排序</h1>
<p>冒泡排序无疑是最为出名的排序算法之一，从序列的一端开始往另一端冒泡（你可以从左往右冒泡，也可以从右往左冒泡，看心情），依次比较相邻的两个数的大小（到底是比大还是比小也看你心情）。</p>
<figure data-type="image" tabindex="2"><img src="https://linuxcpporz.github.io/post-images/1634574775232.gif" alt="" loading="lazy"></figure>
<p>（无序区，有序区）。从无序区通过交换找出最小元素放到有序区前端。</p>
<p>冒泡排序思路：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<h2 id="c实现冒泡排序">C++实现冒泡排序</h2>
<pre><code>void BubbleSort(vector&lt;int&gt;&amp; v) {
    int len = v.size();
    for (int i = 0; i &lt; len - 1; ++i)
        for (int j = 0; j &lt; len - 1 - i; ++j)
            if (v[j] &gt; v[j + 1]) 
                swap(v[j], v[j + 1]);
}
</code></pre>
<h1 id="2-选择排序">2 选择排序</h1>
<p>选择排序的思路是这样的：首先，找到数组中最小的元素，拎出来，将它和数组的第一个元素交换位置，第二步，在剩下的元素中继续寻找最小的元素，拎出来，和数组的第二个元素交换位置，如此循环，直到整个数组排序完成。<br>
至于选大还是选小，这个都无所谓，你也可以每次选择最大的拎出来排，也可以每次选择最小的拎出来的排，只要你的排序的手段是这种方式，都叫选择排序。</p>
<figure data-type="image" tabindex="3"><img src="https://linuxcpporz.github.io/post-images/1634574940781.gif" alt="" loading="lazy"></figure>
<p>（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</p>
<p>选择排序思路：</p>
<ol>
<li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾</li>
<li>以此类推，直到所有元素均排序完毕</li>
</ol>
<h2 id="c实现选择排序">C++实现选择排序</h2>
<pre><code>void SelectionSort(vector&lt;int&gt;&amp; v) {
    int min, len = v.size();
    for (int i = 0; i &lt; len - 1; ++i) {
        min = i;
        for (int j = i + 1; j &lt; len; ++j) {
            if (v[j] &lt; v[min]) {    // 标记最小的
                min = j;
            }
        }
        if (i != min)  // 交换到前面
            swap(v[i], v[min]);
    }
}
</code></pre>
<h1 id="插入排序">插入排序</h1>
<p>插入排序的思想和我们打扑克摸牌的时候一样，从牌堆里一张一张摸起来的牌都是乱序的，我们会把摸起来的牌插入到左手中合适的位置，让左手中的牌时刻保持一个有序的状态。那如果我们不是从牌堆里摸牌，而是左手里面初始化就是一堆乱牌呢？ 一样的道理，我们把牌往手的右边挪一挪，把手的左边空出一点位置来，然后在乱牌中抽一张出来，插入到左边，再抽一张出来，插入到左边，再抽一张，插入到左边，每次插入都插入到左边合适的位置，时刻保持左边的牌是有序的，直到右边的牌抽完，则排序完毕。</p>
<figure data-type="image" tabindex="4"><img src="https://linuxcpporz.github.io/post-images/1634575211446.gif" alt="" loading="lazy"></figure>
<p>（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</p>
<p>插入排序思路：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<h2 id="c实现插入排序">C++实现插入排序</h2>
<pre><code>void InsertSort(vector&lt;int&gt;&amp; v)
{
    int len = v.size();
    for (int i = 1; i &lt; len; ++i) {
        int temp = v[i];
        for(int j = i - 1; j &gt;= 0; --j)
        {
            if(v[j] &gt; temp)
            {
                v[j + 1] = v[j];
                v[j] = temp;
            }
            else
                break;
        }
    }
}
</code></pre>
<h1 id="4-希尔排序">4 希尔排序</h1>
<p>希尔排序这个名字，来源于它的发明者希尔，也称作“缩小增量排序”，是插入排序的一种更高效的改进版本。我们知道，插入排序对于大规模的乱序数组的时候效率是比较慢的，因为它每次只能将数据移动一位，希尔排序为了加快插入的速度，让数据移动的时候可以实现跳跃移动，节省了一部分的时间开支。</p>
<figure data-type="image" tabindex="5"><img src="https://linuxcpporz.github.io/post-images/1634575417121.gif" alt="" loading="lazy"></figure>
<p>希尔排序：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</p>
<h2 id="c实现希尔排序">C++实现希尔排序</h2>
<pre><code>template&lt;typename T&gt;
void shell_sort(T array[], int length) {
    int h = 1;
    while (h &lt; length / 3) {
        h = 3 * h + 1;
    }
    while (h &gt;= 1) {
        for (int i = h; i &lt; length; i++) {
            for (int j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}
</code></pre>
<p>可能你会问为什么区间要以 gap = gap*3 + 1 去计算，其实最优的区间计算方法是没有答案的，这是一个长期未解决的问题，不过差不多都会取在二分之一到三分之一附近。</p>
<h1 id="5-归并排序">5 归并排序</h1>
<p>归并字面上的意思是合并，归并算法的核心思想是分治法，就是将一个数组一刀切两半，递归切，直到切成单个元素，然后重新组装合并，单个元素合并成小数组，两个小数组合并成大数组，直到最终合并完成，排序完毕。</p>
<figure data-type="image" tabindex="6"><img src="https://linuxcpporz.github.io/post-images/1634575552749.gif" alt="" loading="lazy"></figure>
<p>归并排序：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。可从上到下或从下到上进行。</p>
<h2 id="c实现归并排序迭代版">C++实现归并排序（迭代版）</h2>
<pre><code>template&lt;typename T&gt;
void merge_sort(T arr[], int len) {
    T* a = arr;
    T* b = new T[len];
    for (int seg = 1; seg &lt; len; seg += seg) {
        for (int start = 0; start &lt; len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)
                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];
            while (start1 &lt; end1)
                b[k++] = a[start1++];
            while (start2 &lt; end2)
                b[k++] = a[start2++];
        }
        T* temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        for (int i = 0; i &lt; len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}
</code></pre>
<p>归并排序的核心思想是分治，分而治之，将一个大问题分解成无数的小问题进行处理，处理之后再合并，这里我们采用递归来实现：</p>
<h2 id="c实现归并排序递归版">C++实现归并排序（递归版）</h2>
<pre><code>template&lt;typename T&gt;
void merge_sort_recursive(T arr[], T reg[], int start, int end) {
    if (start &gt;= end)
        return;
    int len = end - start, mid = (len &gt;&gt; 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    merge_sort_recursive(arr, reg, start1, end1);
    merge_sort_recursive(arr, reg, start2, end2);
    int k = start;
    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)
        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];
    while (start1 &lt;= end1)
        reg[k++] = arr[start1++];
    while (start2 &lt;= end2)
        reg[k++] = arr[start2++];
    for (k = start; k &lt;= end; k++)
        arr[k] = reg[k];
}
</code></pre>
<h1 id="6-快速排序">6 快速排序</h1>
<p>快速排序的核心思想也是分治法，分而治之。它的实现方式是每次从序列中选出一个基准值，其他数依次和基准值做比较，比基准值大的放右边，比基准值小的放左边，然后再对左边和右边的两组数分别选出一个基准值，进行同样的比较移动，重复步骤，直到最后都变成单个元素，整个数组就成了有序的序列。</p>
<figure data-type="image" tabindex="7"><img src="https://linuxcpporz.github.io/post-images/1634575646139.gif" alt="" loading="lazy"></figure>
<p>（小数，基准元素，大数）。在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</p>
<p>快速排序思路：</p>
<ol>
<li>选取第一个数为基准</li>
<li>将比基准小的数交换到前面，比基准大的数交换到后面</li>
<li>对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<h2 id="c实现快速排序">C++实现快速排序</h2>
<pre><code>void QuickSort(vector&lt;int&gt;&amp; v, int low, int high) {
    if (low &gt;= high)		// 结束标志
        return;
    int first = low;		// 低位下标
    int last = high;		// 高位下标
    int key = v[first];		// 设第一个为基准

    while (first &lt; last)
    {
        // 将比第一个小的移到前面
        while (first &lt; last &amp;&amp; v[last] &gt;= key)
            last--;
        if (first &lt; last)
            v[first++] = v[last];

        // 将比第一个大的移到后面
        while (first &lt; last &amp;&amp; v[first] &lt;= key)
            first++;
        if (first &lt; last)
            v[last--] = v[first];
    }
    // 基准置位
    v[first] = key;
    // 前半递归
    QuickSort(v, low, first - 1);
    // 后半递归
    QuickSort(v, first + 1, high);
}
</code></pre>
<p>快速排序的时间复杂度和归并排序一样，O(n log n)，但这是建立在每次切分都能把数组一刀切两半差不多大的前提下，如果出现极端情况，比如排一个有序的序列，如[ 9，8，7，6，5，4，3，2，1 ]，选取基准值 9 ，那么需要切分 n – 1 次才能完成整个快速排序的过程，这种情况下，时间复杂度就退化成了 O(n^2)，当然极端情况出现的概率也是比较低的。</p>
<p>所以说，快速排序的时间复杂度是 O(nlogn)，极端情况下会退化成 O(n^2)，为了避免极端情况的发生，选取基准值应该做到随机选取，或者是打乱一下数组再选取。</p>
<p>另外，快速排序的空间复杂度为 O(1)。</p>
<h1 id="7-堆排序">7 堆排序</h1>
<p>堆排序顾名思义，是利用堆这种数据结构来进行排序的算法。堆是一种优先队列，两种实现，最大堆和最小堆，由于我们这里排序按升序排，所以就直接以最大堆来说吧。<br>
我们完全可以把堆（以下全都默认为最大堆）看成一棵完全二叉树，但是位于堆顶的元素总是整棵树的最大值，每个子节点的值都比父节点小，由于堆要时刻保持这样的规则特性，所以一旦堆里面的数据发生变化，我们必须对堆重新进行一次构建。<br>
既然堆顶元素永远都是整棵树中的最大值，那么我们将数据构建成堆后，只需要从堆顶取元素不就好了吗？ 第一次取的元素，是否取的就是最大值？取完后把堆重新构建一下，然后再取堆顶的元素，是否取的就是第二大的值？ 反复的取，取出来的数据也就是有序的数据。</p>
<figure data-type="image" tabindex="8"><img src="https://linuxcpporz.github.io/post-images/1634575824751.gif" alt="" loading="lazy"></figure>
<h2 id="c实现堆排序">C++实现堆排序</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
// 堆排序：（最大堆，有序区）。从堆顶把根卸出来放在有序区之前，再恢复堆。
void max_heapify(int arr[], int start, int end) {

    int dad = start;
    int son = dad * 2 + 1;
    while (son &lt;= end) { 
        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1])
            son++;
        if (arr[dad] &gt; arr[son]) 
            return;
        else { 
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) {
    for (int i = len / 2 - 1; i &gt;= 0; i--)
        max_heapify(arr, i, len - 1);
    for (int i = len - 1; i &gt; 0; i--) {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main() {
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i &lt; len; i++)
        cout &lt;&lt; arr[i] &lt;&lt; ' ';
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<h1 id="8-计数排序">8 计数排序</h1>
<p>计数排序是一种非基于比较的排序算法，我们之前介绍的各种排序算法几乎都是基于元素之间的比较来进行排序的，计数排序的时间复杂度为 O(n + m )，m 指的是数据量，说的简单点，计数排序算法的时间复杂度约等于 O(n)，快于任何比较型的排序算法。</p>
<figure data-type="image" tabindex="9"><img src="https://linuxcpporz.github.io/post-images/1634575892087.gif" alt="" loading="lazy"></figure>
<p>计数排序：统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p>
<p>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。<br>
如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。<br>
计数排序不是比较排序，排序的速度快于任何比较排序算法。<br>
时间复杂度为 O（n+k），空间复杂度为 O（n+k）</p>
<p>算法的步骤如下：</p>
<ol>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 C[i] 项，每放一个元素就将 C[i] 减去 1</li>
</ol>
<h2 id="c实现计数排序">C++实现计数排序</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

// 计数排序
void CountSort(vector&lt;int&gt;&amp; vecRaw, vector&lt;int&gt;&amp; vecObj)
{
    // 确保待排序容器非空
    if (vecRaw.size() == 0)
        return;

    // 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小
    int vecCountLength = (*max_element(begin(vecRaw), end(vecRaw))) + 1;
    vector&lt;int&gt; vecCount(vecCountLength, 0);

    // 统计每个键值出现的次数
    for (int i = 0; i &lt; vecRaw.size(); i++)
        vecCount[vecRaw[i]]++;
    
    // 后面的键值出现的位置为前面所有键值出现的次数之和
    for (int i = 1; i &lt; vecCountLength; i++)
        vecCount[i] += vecCount[i - 1];

    // 将键值放到目标位置
    for (int i = vecRaw.size(); i &gt; 0; i--)	// 此处逆序是为了保持相同键值的稳定性
        vecObj[--vecCount[vecRaw[i - 1]]] = vecRaw[i - 1];
}

int main()
{
    vector&lt;int&gt; vecRaw = { 0,5,7,9,6,3,4,5,2,8,6,9,2,1 };
    vector&lt;int&gt; vecObj(vecRaw.size(), 0);

    CountSort(vecRaw, vecObj);

    for (int i = 0; i &lt; vecObj.size(); ++i)
        cout &lt;&lt; vecObj[i] &lt;&lt; &quot;  &quot;;
    cout &lt;&lt; endl;

    return 0;
}
</code></pre>
<h2 id="计数局限性">计数局限性</h2>
<p>计数排序的毛病很多，我们来找找 bug 。</p>
<p>如果我要排的数据里有 0 呢？ int[] 初始化内容全是 0 ，排毛线。</p>
<p>如果我要排的数据范围比较大呢？比如[ 1，9999 ]，我排两个数你要创建一个 int[10000] 的数组来计数？</p>
<p>对于第一个 bug ，我们可以使用偏移量来解决，比如我要排[ -1，0，-3 ]这组数字，这个简单，我全给你们加 10 来计数，变成[ 9，10，7 ]计完数后写回原数组时再减 10。不过有可能也会踩到坑，万一你数组里恰好有一个 -10，你加上 10 后又变 0 了，排毛线。</p>
<p>对于第二个 bug ，确实解决不了，如果是[ 9998，9999 ]这种虽然值大但是相差范围不大的数据我们也可以使用偏移量解决，比如这两个数据，我减掉 9997 后只需要申请一个 int[3] 的数组就可以进行计数。</p>
<p>由此可见，计数排序只适用于正整数并且取值范围相差不大的数组排序使用，它的排序的速度是非常可观的。</p>
<h1 id="9-桶排序">9 桶排序</h1>
<p>桶排序可以看成是计数排序的升级版，它将要排的数据分到多个有序的桶里，每个桶里的数据再单独排序，再把每个桶的数据依次取出，即可完成排序。</p>
<figure data-type="image" tabindex="10"><img src="https://linuxcpporz.github.io/post-images/1634576033208.gif" alt="" loading="lazy"></figure>
<p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。</p>
<p>桶排序序思路：</p>
<ol>
<li>设置一个定量的数组当作空桶子。</li>
<li>寻访序列，并且把项目一个一个放到对应的桶子去。</li>
<li>对每个不是空的桶子进行排序。</li>
<li>从不是空的桶子里把项目再放回原来的序列中。</li>
</ol>
<p>假设数据分布在[0，100)之间，每个桶内部用链表表示，在数据入桶的同时插入排序，然后把各个桶中的数据合并。</p>
<h2 id="c实现桶排序">C++实现桶排序</h2>
<pre><code>#include&lt;iterator&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
using std::vector;

const int BUCKET_NUM = 10;

struct ListNode{
    explicit ListNode(int i=0):mData(i),mNext(NULL){}
    ListNode* mNext;
    int mData;
};

ListNode* insert(ListNode* head,int val){
    ListNode dummyNode;
    ListNode *newNode = new ListNode(val);
    ListNode *pre,*curr;
    dummyNode.mNext = head;
    pre = &amp;dummyNode;
    curr = head;
    while(NULL!=curr &amp;&amp; curr-&gt;mData&lt;=val){
        pre = curr;
        curr = curr-&gt;mNext;
    }
    newNode-&gt;mNext = curr;
    pre-&gt;mNext = newNode;
    return dummyNode.mNext;
}


ListNode* Merge(ListNode *head1,ListNode *head2){
    ListNode dummyNode;
    ListNode *dummy = &amp;dummyNode;
    while(NULL!=head1 &amp;&amp; NULL!=head2){
        if(head1-&gt;mData &lt;= head2-&gt;mData){
            dummy-&gt;mNext = head1;
            head1 = head1-&gt;mNext;
        }else{
            dummy-&gt;mNext = head2;
            head2 = head2-&gt;mNext;
        }
        dummy = dummy-&gt;mNext;
    }
    if(NULL!=head1) dummy-&gt;mNext = head1;
    if(NULL!=head2) dummy-&gt;mNext = head2;
    
    return dummyNode.mNext;
}

void BucketSort(int n,int arr[]){
    vector&lt;ListNode*&gt; buckets(BUCKET_NUM,(ListNode*)(0));
    for(int i=0;i&lt;n;++i){
        int index = arr[i]/BUCKET_NUM;
        ListNode *head = buckets.at(index);
        buckets.at(index) = insert(head,arr[i]);
    }
    ListNode *head = buckets.at(0);
    for(int i=1;i&lt;BUCKET_NUM;++i){
        head = Merge(head,buckets.at(i));
    }
    for(int i=0;i&lt;n;++i){
        arr[i] = head-&gt;mData;
        head = head-&gt;mNext;
    }
}
</code></pre>
<h1 id="10-基数排序">10 基数排序</h1>
<p>基数排序是一种非比较型整数排序算法，其原理是将数据按位数切割成不同的数字，然后按每个位数分别比较。<br>
假设说，我们要对 100 万个手机号码进行排序，应该选择什么排序算法呢？排的快的有归并、快排时间复杂度是 O(nlogn)，计数排序和桶排序虽然更快一些，但是手机号码位数是11位，那得需要多少桶？内存条表示不服。<br>
这个时候，我们使用基数排序是最好的选择。</p>
<figure data-type="image" tabindex="11"><img src="https://linuxcpporz.github.io/post-images/1634576134494.gif" alt="" loading="lazy"></figure>
<p>基数排序：一种多关键字的排序算法，可用桶排序实现。</p>
<h2 id="c实现基数排序">C++实现基数排序</h2>
<pre><code>int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];		///&lt; 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i &lt; n; ++i)
    {
        if (maxData &lt; data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData &gt;= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i &lt; n; ++i)
    {
        while(data[i] &gt;= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i &lt;= d; i++) //进行d次排序
    {
        for(j = 0; j &lt; 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j &lt; n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j &lt; 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j &gt;= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j &lt; n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
</code></pre>

                </div>
            </article>
        </main>
    </div>
    <div class="doc-footer-nav mdui-color-theme">
        <div class="mdui-container">
            <div class="mdui-row">
                
                <div class="mdui-col-xs-2 mdui-col-sm-6 doc-footer-nav-left"></div>
                
                
                <a href="https://linuxcpporz.github.io/post/shi-si-chong-chang-jian-de-suan-fa/" class="mdui-ripple mdui-color-theme mdui-col-xs-10 mdui-col-sm-6 doc-footer-nav-right">
                    <div class="doc-footer-nav-text">
                        <i class="mdui-icon material-icons">arrow_forward</i>
                        <span class="doc-footer-nav-direction">下一篇文章</span>
                        <div class="doc-footer-nav-chapter">十四种常见的算法</div>
                    </div>
                </a>
                
            </div>
        </div>
    </div>
    <br>
    
        
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

    var gitalk = new Gitalk({
        clientID: 'a77b448ff65a1a73fe8a',
        clientSecret: '6ea09d173e655496fdde38f90d00f7345cc5b02d',
        repo: 'LinuxCpporz.github.io',
        owner: 'LinuxCpporz',
        admin: ['LinuxCpporz'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
    })

    gitalk.render('gitalk-container')

</script>

        

        
    
    
</div>
<footer class="mdui-container footer ">
<!--    <div class="head_card-offset"></div>-->
    <div class="mdui-row mdui-row-gapless">
        <div class="k-container">
            <img width="100%" src="/media/img/skirt.png">
        </div>
    </div>

    <div class="site-info">
        <span id="runtime_span"></span>
<script type="text/javascript">
    function show_runtime(){window.setTimeout("show_runtime()",1000);
    X=new Date("10/17/2021 0:42:02");Y=new Date();T=(Y.getTime()-X.getTime());
    M=24*60*60*1000;a=T/M;A=Math.floor(a);b=(a-A)*24;B=Math.floor(b);c=(b-B)*60;
    C=Math.floor((b-B)*60);D=Math.floor((c-C)*60);
    runtime_span.innerHTML="本站勉强运行: "+A+"天"+B+"小时"+C+"分"+D+"秒"}show_runtime();
</script>
    </div>
</footer>
<div id="landlord" style="left:5px;bottom:0px;">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
            <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
            <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
            <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        <div class="live_ico_item type_music" id="musicButton"></div>
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input name="live2dBGM" value="https://img.apa70.com/123.mp3" type="hidden">
        <input id="duType" value="douqilai,l2d_caihong" type="hidden">
    </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script>
    var message_Path = '/media/live2d/';//资源目录，如果目录不对请更改
    var talkAPI = "";//如果有类似图灵机器人的聊天接口请填写接口路径
</script>
<!--<script src="/media/js/jquery-3.3.1.min.js"></script>-->
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/js/message.js"></script>

</body>
<script src="//cdn.jsdelivr.net/npm/mdui@1.0.0/dist/js/mdui.min.js"></script>
<script src="/media/layer/layer.js"></script>
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@4.11.1/dist/av-min.js"></script>
<script src="//unpkg.com/vue@next"></script>
<script>
    
</script>
<script type="module" src="/media/js/post.js"></script>
</html>
